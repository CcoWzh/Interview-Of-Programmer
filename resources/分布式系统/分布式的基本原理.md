# 分布式的基本原理

### 拜占庭将军问题

拜占庭将军问题是Leslie Lamport（2013年的图灵讲得住）用来为描述**分布式系统一致性问题**（Distributed Consensus）在[论文](https://link.zhihu.com/?target=http%3A//lamport.azurewebsites.net/pubs/byz.pdf)中抽象出来一个著名的例子。

这个例子大意是这样的：

拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？

> 拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。所以，在研究拜占庭将军问题的时候，已经假定了信道是没有问题的.

### 同步和异步

分布式系统总的计算机通过互相之间的“消息传递”来沟通和协作。消息可以通过任何一种消息协议传递，比如 HTTP 或者 RPC，亦或是为特定系统实现的一套定制协议。有两种消息传递的环境：

**同步**

在同步系统中，我们假定消息会在一个固定且已知的时间范围内接收到。

同步消息传递在概念上更简单，因为用户会有一个时间上的保证：当他们发送某条消息后，接收方会在一定时间内收到它。这就使得用户可以为他们的协议设置一个消息传递的耗时上限。

但是，这种假设在现实生活当中的分布式系统中不切实际：因为组件计算机们可能会崩溃，或者下线，而且消息也可能丢包，重复，延时或者没有按照发送顺序被接收。

**异步**

在异步消息传递系统中，我们假定系统可能导致某条消息一直被延误，导致消息重放，或者乱序发送消息。换句话说，在这种环境下，消息传递的预期耗时是没有上限的。

异步是指系统中各个节点可能存在较大的时钟差异，同时消息传输时间是任意长的，各节点对消息进行处理的时间也可能是任意长的。（**学术语言解释**）

### FLP 不可能定理

现实生活中的系统往往都是异步系统。因为系统中各个节点之间的延时，是否宕机等等都是不确定的。那么，在最小化异步模型系统中，是否存在一个可以解决一致性问题的确定性共识算法？

由Fischer、Lynch和Patterson三位科学家于1985年发表的论文《Impossibility of Distributed Consensus with One Faulty Process》指出：

> 在异步模型中，分布式系统中只要有一个进程不可用（失去响应或暂停），就可能无法达成整体的共识。（No completely asynchronous consensus protocol can tolerate even a single unannounced process death）。

以上结论被称为FLP不可能原理。该定理被认为是分布式系统中重要的原理之一。

这个结果对分布式计算领域带来重大打击，但即使如此，科学家仍在不断尝试避开 FLP 不可能性问题的方法。

抽象一点来说，有两个方法能够避开 FLP 不可能性问题：

- 使用同步性假设
- 使用非确定性机制

**同步性假设**

FLP不可能定理，这个发现没有证明共识不能达成。而且——因为消息异步传递，所以“不可能”在固定时间达成共识——这里说的“不可能”，指的是共识“并非总能”达成。这是个微妙但至关重要的细节。

这个规避 FLP 不可能问题的方法就是引入超时（timeout）的概念。如果在确认下个值的过程没有进展，我们会等到超时，然后重新进行共识的步骤。如我们所见，Paxos 和 Raft 使用的就是这类共识算法。

**使用非确定性机制**

中本聪共识！在传统的共识中，状态转变函数 **f(x)** 是这样定义的：提案者和一众接收者必须全体协作决定下一状态的值。

这种做法未免过于复杂了，因为这要求我们明晰每一个节点的状态，*并且* 每一个节点都要与其余所有的节点交换数据（也就是说信息交换量达到 $O(n^2)$ ）。由此显而易见，传统共识不具备良好的可拓展性，且无法在开放、用户能无需特别许可，随时加入随时退出的分布式系统中达成。

中本聪共识的精妙之处在于把上述问题转变成一个概率问题。与其让所有节点对一个确定的值达成一致，不如构造 f(x) 来使所有节点对某一输出值正确性的概率达成一致。

#### FLP 不可能定理的证明

参考文献[分布式系统中的FLP不可能原理、CAP理论与BASE理论(顺带提一下ACID)](https://blog.csdn.net/JH_Zhai/article/details/80265308)

### CAP理论

> CAP理论指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

#### 一致性

描述当前所有节点存储数据的统一模型，分为强一致性和弱一致性：
强一致性描述了所有节点的数据高度一致，无论从哪个节点读取，都是一样的。无需担心同一时刻会获得不同的数据。是级别最高的，实现的代价比较高
  ![img](https://img-blog.csdn.net/20140703205928984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3VnZU1pY2hhZWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
弱一致性又分为单调一致性和最终一致性：

1. 单调一致性强调数据是按照时间的新旧，单调向最新的数据靠近，不会回退，如：数据存在三个版本`v1->v2->v3`，获取只能向`v3`靠近(如取到的是`v2`，就不可能再次获得`v1`)
2. 最终一致性强调数据经过一个时间窗口之后，只要多尝试几次，最终的状态是一致的，是最新的数据
   ![img](https://img-blog.csdn.net/20140703205932062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR3VnZU1pY2hhZWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

强一致性的场景，就好像交易系统，存取钱的+/-操作必须是马上一致的，否则会令很多人误解。
弱一致性的场景，大部分就像web互联网的模式，比如发了一条微博，改了某些配置，可能不会马上生效，但刷新几次后就可以看到了，其实弱一致性就是在系统上通过业务可接受的方式换取了一些系统的低复杂度和可用性。

#### 可用性

保证系统的正常可运行性，在请求方看来，只要发送了一个请求，就可以得到恢复无论成功还是失败（不会超时）!

#### 分区容忍性

在系统某些节点或网络有异常的情况下，系统依旧可以继续服务。这通常是有负载均衡和副本来支撑的。例如计算模块异常可通过负载均衡引流到其他平行节点，存储模块通过其他几点上的副本来对外提供服务。

#### CAP理论的证明

参考文献[分布式系统中的FLP不可能原理、CAP理论与BASE理论(顺带提一下ACID)](https://blog.csdn.net/JH_Zhai/article/details/80265308)

### BASE理论

BASE理论是有`eBay`的架构师`Dan Pritchett`源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。

BASE理论的定义:

> BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。

#### 基本可用（Basically Available）

基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。

#### 软状态（ Soft State）

软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。
分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。

#### 最终一致性（ Eventual Consistency）

最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。

> BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

### RPC基本原理

RPC 远程服务调用是分布式服务架构的基础，无论微服务设计上层如何发展，讨论服务治理都绕不开远程服务调用，那么如何理解 RPC、有哪些常见的 RPC 框架、实现一款 RPC 框架需要哪些技术呢？

#### 什么是RPC

RPC（Remote Procedure Call）是一种进程间通信方式，百科给出的定义是这样的：“RPC（远程过程调用协议），它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议”。

RPC 允许程序调用另一个地址空间的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。

> 比如两台服务器 A、B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数或者方法，由于不在一个内存空间，则不能直接调用，这时候就可以应用 RPC 框架的实现来解决。

#### RPC 框架代表

开源社区里有许多优秀的 RPC 框架，比如常用的 Dubbo、Thrift、gRPC 等，下面简单介绍一下这几款组件。

**gRPC原理**

GRPC是google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，基于`protobuf 3.x`，基于`Netty 4.x +`。GRPC与thrift、avro-rpc等其实在总体原理上并没有太大的区别，简而言之GRPC并没有太多突破性的创新。

使用的基本流程是：

1. 需要使用protobuf定义接口，即`.proto`文件
2. 然后使用compile工具生成特定语言的执行代码，比如JAVA、C/C++、Python等。类似于thrift，为了解决跨语言问题。
3. 启动一个Server端，server端通过侦听指定的port，来等待Client链接请求，通常使用Netty来构建，GRPC内置了Netty的支持。
4. 启动一个或者多个Client端，Client也是基于Netty，Client通过与Server建立TCP长链接，并发送请求；Request与Response均被封装成HTTP2的stream Frame，通过Netty Channel进行交互。

### 参考文献

- [分布式系统基本原理](https://blog.csdn.net/armygan/article/details/79964678)

- [分布式系统中的FLP不可能原理、CAP理论与BASE理论(顺带提一下ACID)](https://blog.csdn.net/JH_Zhai/article/details/80265308)

- [FLP不可能原理](https://www.cnblogs.com/firstdream/p/6585923.html)

