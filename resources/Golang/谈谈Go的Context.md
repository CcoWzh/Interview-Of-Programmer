# 谈谈Go的Context

在Go服务器中，每个传入请求都在其自己的goroutine中处理。 请求处理程序通常会启动其他goroutine来访问后端，例如数据库和RPC服务。 处理请求的goroutine集合通常需要访问特定于请求的值，例如最终用户的身份，授权令牌和请求的截止日期。 当请求被取消或超时时，处理该请求的所有goroutine都应该快速退出，以便系统可以回收他们正在使用的任何资源。

Context是专门用来简化对于处理单个请求,多个goroutine之间数据共享、取消信号、超时处理等相关操作。

## 使用场景

- 并发多服务调用情况下,比如一个请求进来，启动3个goroutine进行 RpcA 、RpcB 、RpcC三个服务的调用。这时候只要有其中一个服务错误，就返回错误，同时取消另外两个Rpc服务。可以通过 WithCancel 方法来实现。
- 超时请求，比如对Http、Rpc进行超时限制，可以通过 `WithDeadline` 和 `WithTimeout` 来实现。
- 携带数据，比如一个请求的用户信息，一般业务场景，我们会有一个专门的中间件来校验用户信息，然后把用户信息注入到context中，或者共享给派生出来的多个goroutine使用，可以通过 `WithValue` 方法实现。

`context`主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用`context`时有两点值得注意：上游任务仅仅使用`context`通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说`context`的取消操作是无侵入的；`context`是线程安全的，因为`context`本身是不可变的（`immutable`），因此可以放心地在多个协程中传递使用。

